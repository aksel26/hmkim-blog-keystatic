name: Send Newsletter on New Post

on:
  push:
    branches: [main]
    paths:
      - "apps/blog/content/**/*.mdoc"
  pull_request:
    types: [closed]
    branches: [main]
    paths:
      - "apps/blog/content/**/*.mdoc"

jobs:
  send-newsletter:
    # push 이벤트이거나, PR이 merge된 경우에만 실행
    if: github.event_name == 'push' || github.event.pull_request.merged == true
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Get added mdoc files
        id: changed-files
        uses: tj-actions/changed-files@v44
        with:
          files: |
            apps/blog/content/**/*.mdoc

      - name: Setup Node.js
        if: steps.changed-files.outputs.added_files != ''
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install yq
        if: steps.changed-files.outputs.added_files != ''
        uses: mikefarah/yq@v4

      - name: Extract post info and send newsletter
        if: steps.changed-files.outputs.added_files != ''
        env:
          NEWSLETTER_API_KEY: ${{ secrets.NEWSLETTER_API_KEY }}
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          VERCEL_PROJECT_ID: ${{ vars.VERCEL_PROJECT_ID }}
          AGENT_WEB_URL: ${{ vars.AGENT_WEB_URL }}
          BLOG_URL: ${{ vars.BLOG_URL }}
          ADDED_FILES: ${{ steps.changed-files.outputs.added_files }}
        run: |
          # 첫 번째 추가된 파일 처리
          FIRST_FILE=$(echo "$ADDED_FILES" | cut -d' ' -f1)

          if [ -z "$FIRST_FILE" ]; then
            echo "No new mdoc files found"
            exit 0
          fi

          echo "Processing file: $FIRST_FILE"

          # YAML frontmatter 추출 (--- 사이의 내용)
          FRONTMATTER=$(sed -n '1,/^---$/p' "$FIRST_FILE" | tail -n +2 | sed '$d')

          # yq를 사용하여 YAML 정확히 파싱
          STATUS=$(echo "$FRONTMATTER" | yq '.status // ""')
          echo "Post status: $STATUS"

          if [ "$STATUS" != "published" ]; then
            echo "Post is not published (status: $STATUS), skipping newsletter"
            exit 0
          fi

          # yq로 title, summary, thumbnailImage 추출 (block scalar 지원)
          TITLE=$(echo "$FRONTMATTER" | yq '.title // ""')
          SUMMARY=$(echo "$FRONTMATTER" | yq '.summary // ""' | tr '\n' ' ' | sed 's/  */ /g' | sed 's/^ *//;s/ *$//')
          THUMBNAIL_PATH=$(echo "$FRONTMATTER" | yq '.thumbnailImage // ""')

          # 카테고리와 슬러그 추출
          if [[ "$FIRST_FILE" == *"/tech/"* ]]; then
            CATEGORY="tech"
          else
            CATEGORY="life"
          fi

          SLUG=$(basename "$FIRST_FILE" .mdoc)
          POST_URL="${BLOG_URL}/${CATEGORY}/${SLUG}"

          # 썸네일 URL 생성 (경로가 있는 경우)
          if [ -n "$THUMBNAIL_PATH" ]; then
            THUMBNAIL_URL="${BLOG_URL}${THUMBNAIL_PATH}"
          else
            THUMBNAIL_URL=""
          fi

          echo "Title: $TITLE"
          echo "Summary: $SUMMARY"
          echo "URL: $POST_URL"
          echo "Thumbnail: $THUMBNAIL_URL"

          # 뉴스레터 발송 API 호출
          if [ -n "$TITLE" ] && [ -n "$SUMMARY" ]; then
            # Vercel API로 배포 완료 대기
            echo "Waiting for Vercel deployment to complete..."
            MAX_WAIT=600  # 최대 10분 대기
            WAIT_INTERVAL=30  # 30초 간격으로 확인
            ELAPSED=0
            DEPLOY_SUCCESS=false

            while [ $ELAPSED -lt $MAX_WAIT ]; do
              # Vercel API로 최신 배포 상태 확인
              DEPLOY_RESPONSE=$(curl -s -H "Authorization: Bearer ${VERCEL_TOKEN}" \
                "https://api.vercel.com/v6/deployments?projectId=${VERCEL_PROJECT_ID}&limit=1")

              DEPLOY_STATE=$(echo "$DEPLOY_RESPONSE" | jq -r '.deployments[0].state // "UNKNOWN"')
              DEPLOY_URL=$(echo "$DEPLOY_RESPONSE" | jq -r '.deployments[0].url // ""')

              echo "Deployment state: $DEPLOY_STATE (elapsed: ${ELAPSED}s)"

              if [ "$DEPLOY_STATE" = "READY" ]; then
                echo "Deployment complete! URL: $DEPLOY_URL"
                DEPLOY_SUCCESS=true
                break
              elif [ "$DEPLOY_STATE" = "ERROR" ] || [ "$DEPLOY_STATE" = "CANCELED" ]; then
                echo "Deployment failed with state: $DEPLOY_STATE"
                break
              elif [ "$DEPLOY_STATE" = "QUEUED" ] || [ "$DEPLOY_STATE" = "INITIALIZING" ] || \
                   [ "$DEPLOY_STATE" = "ANALYZING" ] || [ "$DEPLOY_STATE" = "BUILDING" ] || \
                   [ "$DEPLOY_STATE" = "DEPLOYING" ]; then
                echo "Deployment in progress: $DEPLOY_STATE"
                # continue waiting
              else
                echo "Unknown deployment state: $DEPLOY_STATE"
              fi

              sleep $WAIT_INTERVAL
              ELAPSED=$((ELAPSED + WAIT_INTERVAL))
            done

            if [ "$DEPLOY_SUCCESS" = false ]; then
              echo "Warning: Deployment not ready after ${ELAPSED}s. Skipping newsletter."
              exit 0
            fi

            # JSON 페이로드 생성
            JSON_PAYLOAD="{\"postTitle\": \"${TITLE}\", \"postSummary\": \"${SUMMARY}\", \"postUrl\": \"${POST_URL}\", \"postCategory\": \"${CATEGORY}\""
            if [ -n "$THUMBNAIL_URL" ]; then
              JSON_PAYLOAD="${JSON_PAYLOAD}, \"postThumbnail\": \"${THUMBNAIL_URL}\""
            fi
            JSON_PAYLOAD="${JSON_PAYLOAD}}"

            curl -X POST "${AGENT_WEB_URL}/api/newsletter/send" \
              -H "Content-Type: application/json" \
              -H "Authorization: Bearer ${NEWSLETTER_API_KEY}" \
              -d "$JSON_PAYLOAD"
          else
            echo "Could not extract title or summary from file"
          fi
